{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Enowars \u00b6 Enowars is a Framework for running A/D CTF events. Overview \u00b6 It's complex: graph TB EnoLauncher EnoEngine EnoFlagSink EnoELK database[(Database)] router{Router} checker1[[Checker 1..N]] router --> team router --> EnoFlagSink EnoEngine -->|send logs| EnoELK EnoEngine -->|send scoreboard data| EnoScoreboard EnoEngine -->|plan checks| database database -->|get reports| EnoEngine EnoLauncher -->|run| checker1 EnoLauncher -->|report| database EnoFlagSink --> database checker1 --> router checker1 -->|send logs| EnoELK subgraph teams[Team Networks] team[Team 1..N] end Now that you've seen this beautiful \ud83d\ude01 chart everything should be clear. For everyone else see below. Infrastructure \u00b6 Click here to get up and running with the underlying OS and Network stuff . If you are the software guy/girl have a look at the engine . Services and Checkers \u00b6 If you want to program your own service and submit it to us have a look at our Create a service Guide . Previous Services can be found on our Github Page Miscellaneous \u00b6 To support everything we have an army of rogue shell and python scripts, as well as Libraries for testing. EnoChecker TBD: Specification","title":"Home"},{"location":"index.html#welcome-to-enowars","text":"Enowars is a Framework for running A/D CTF events.","title":"Welcome to Enowars"},{"location":"index.html#overview","text":"It's complex: graph TB EnoLauncher EnoEngine EnoFlagSink EnoELK database[(Database)] router{Router} checker1[[Checker 1..N]] router --> team router --> EnoFlagSink EnoEngine -->|send logs| EnoELK EnoEngine -->|send scoreboard data| EnoScoreboard EnoEngine -->|plan checks| database database -->|get reports| EnoEngine EnoLauncher -->|run| checker1 EnoLauncher -->|report| database EnoFlagSink --> database checker1 --> router checker1 -->|send logs| EnoELK subgraph teams[Team Networks] team[Team 1..N] end Now that you've seen this beautiful \ud83d\ude01 chart everything should be clear. For everyone else see below.","title":"Overview"},{"location":"index.html#infrastructure","text":"Click here to get up and running with the underlying OS and Network stuff . If you are the software guy/girl have a look at the engine .","title":"Infrastructure"},{"location":"index.html#services-and-checkers","text":"If you want to program your own service and submit it to us have a look at our Create a service Guide . Previous Services can be found on our Github Page","title":"Services and Checkers"},{"location":"index.html#miscellaneous","text":"To support everything we have an army of rogue shell and python scripts, as well as Libraries for testing. EnoChecker TBD: Specification","title":"Miscellaneous"},{"location":"rules.html","text":"Rules \u00b6 Flag format: ENO[A-Za-z0-9+\\/=]{48} The game will start on the specified time (UTC time!). You must register at least X hours before the specified time. You must check in between X hours and X hours before the start time. You must start your vulnbox once the game starts. A round lasts 60 seconds, flags are valid for several rounds. Flag submission: netcat flags.bambi.ovh 1337 Scoring \u00b6 We are currently using the scoring formula by Faust CTF https://2019.faustctf.net/information/rules/ . Social Conduct \u00b6 The vulnerable services of your opponents are your only valid targets. Do not engage anything else! Do not attempt to exhaust resources on your opponents' vulnboxes, for example by sending excessive amounts of requests or exploiting vulnerabilities leading to a denial of service. Vulnboxes and VPN servers are provided by us, you don't have to provide or take care of anything.","title":"Rules"},{"location":"rules.html#rules","text":"Flag format: ENO[A-Za-z0-9+\\/=]{48} The game will start on the specified time (UTC time!). You must register at least X hours before the specified time. You must check in between X hours and X hours before the start time. You must start your vulnbox once the game starts. A round lasts 60 seconds, flags are valid for several rounds. Flag submission: netcat flags.bambi.ovh 1337","title":"Rules"},{"location":"rules.html#scoring","text":"We are currently using the scoring formula by Faust CTF https://2019.faustctf.net/information/rules/ .","title":"Scoring"},{"location":"rules.html#social-conduct","text":"The vulnerable services of your opponents are your only valid targets. Do not engage anything else! Do not attempt to exhaust resources on your opponents' vulnboxes, for example by sending excessive amounts of requests or exploiting vulnerabilities leading to a denial of service. Vulnboxes and VPN servers are provided by us, you don't have to provide or take care of anything.","title":"Social Conduct"},{"location":"infrastructure/engine.html","text":"Engine Installation \u00b6 Overview \u00b6 The Engine is the core Software glueing everything togehter, it consists of: EnoEngine EnoLauncher EnoFlagSink EnoELK Elasticsearch (search engine, noSQL) Logstash (ingest and transform data) Kibana (webfrontend) EnoMoloch ScoreBoard Setup \u00b6 How to setup the engine for a CTF?","title":"Installation"},{"location":"infrastructure/engine.html#engine-installation","text":"","title":"Engine Installation"},{"location":"infrastructure/engine.html#overview","text":"The Engine is the core Software glueing everything togehter, it consists of: EnoEngine EnoLauncher EnoFlagSink EnoELK Elasticsearch (search engine, noSQL) Logstash (ingest and transform data) Kibana (webfrontend) EnoMoloch ScoreBoard","title":"Overview"},{"location":"infrastructure/engine.html#setup","text":"How to setup the engine for a CTF?","title":"Setup"},{"location":"infrastructure/infrastructure.html","text":"Infrastructure Setup \u00b6 Getting started \u00b6 Everything is inside here: https://github.com/enowars/bambictf","title":"Setup"},{"location":"infrastructure/infrastructure.html#infrastructure-setup","text":"","title":"Infrastructure Setup"},{"location":"infrastructure/infrastructure.html#getting-started","text":"Everything is inside here: https://github.com/enowars/bambictf","title":"Getting started"},{"location":"infrastructure/round.html","text":"Inner Workings \u00b6 In order to store flags to capture and check whether a teams service is still running nominally the Engine dispatches several requests in each round. Request Types \u00b6 Request Purpose putflag Inserts the flag into the service getflag Retrieves the flag from the service havoc Checks the service functionality putnoise Insert other (public) data into the service getnoise Check other (public) data Basic requests \u00b6 sequenceDiagram Gameserver->>+Checker: putflag Checker->>+Service: store flag Gameserver->>+Checker: getflag Checker->>+Service: retrieve flag Service->>+Checker: retrieve flag Timing \u00b6 One round generally lasts 60 seconds. It is divided into 4 quarters, which each last 15 seconds. The checker tasks are called in the depicted way: TODO: Are those scheduled right (the slides differ)? gantt title Timing dateFormat mm-ss axisFormat %M-%S section Round 1 putflag (Round 1 flags) :r1p1, 00-00, 15s getflag (old flags) :r0g2, 00-00, 15s getflag (old flags) :r0g2, 00-30, 15s havoc :r1h1, 00-30, 15s putnoise :r1pn1, 00-30, 15s getflag (Round 1 flags) :r1g1, 00-45, 15s getflag (old flags) :r0g3, 00-45, 15s section Round 2 putflag :a1, 01-00, 15s","title":"Timing of a round"},{"location":"infrastructure/round.html#inner-workings","text":"In order to store flags to capture and check whether a teams service is still running nominally the Engine dispatches several requests in each round.","title":"Inner Workings"},{"location":"infrastructure/round.html#request-types","text":"Request Purpose putflag Inserts the flag into the service getflag Retrieves the flag from the service havoc Checks the service functionality putnoise Insert other (public) data into the service getnoise Check other (public) data","title":"Request Types"},{"location":"infrastructure/round.html#basic-requests","text":"sequenceDiagram Gameserver->>+Checker: putflag Checker->>+Service: store flag Gameserver->>+Checker: getflag Checker->>+Service: retrieve flag Service->>+Checker: retrieve flag","title":"Basic requests"},{"location":"infrastructure/round.html#timing","text":"One round generally lasts 60 seconds. It is divided into 4 quarters, which each last 15 seconds. The checker tasks are called in the depicted way: TODO: Are those scheduled right (the slides differ)? gantt title Timing dateFormat mm-ss axisFormat %M-%S section Round 1 putflag (Round 1 flags) :r1p1, 00-00, 15s getflag (old flags) :r0g2, 00-00, 15s getflag (old flags) :r0g2, 00-30, 15s havoc :r1h1, 00-30, 15s putnoise :r1pn1, 00-30, 15s getflag (Round 1 flags) :r1g1, 00-45, 15s getflag (old flags) :r0g3, 00-45, 15s section Round 2 putflag :a1, 01-00, 15s","title":"Timing"},{"location":"infrastructure/test-setup.html","text":"Test Setup \u00b6 If you want a cheap way to test all of your service and infrastructure on one VM, that's you guide. Installation \u00b6 Managing the server \u00b6 # Start Engine Services bash tmux.sh # Monitor EnoEngine tmux a -t enoengine_session","title":"Test Setup"},{"location":"infrastructure/test-setup.html#test-setup","text":"If you want a cheap way to test all of your service and infrastructure on one VM, that's you guide.","title":"Test Setup"},{"location":"infrastructure/test-setup.html#installation","text":"","title":"Installation"},{"location":"infrastructure/test-setup.html#managing-the-server","text":"# Start Engine Services bash tmux.sh # Monitor EnoEngine tmux a -t enoengine_session","title":"Managing the server"},{"location":"infrastructure/testing.html","text":"Test run the infrastructure \u00b6 https://github.com/enowars/enochecker_test","title":"Testing"},{"location":"infrastructure/testing.html#test-run-the-infrastructure","text":"https://github.com/enowars/enochecker_test","title":"Test run the infrastructure"},{"location":"play/general.html","text":"Playing a CTF \u00b6 General \u00b6 A typical attack/defense CTF consists of three components. The Gameserver \u00b6 It is provided by the organizers and runs throughout the competition, starting when the network is opened. It periodically stores flags on your Vulnbox using functionality in the provided services. It then later retrieves these flags, again using existing functionality. The Gameserver does not run exploits! It simply uses the service as intended. Now, why can't the other teams then simply do what the Gameserver does? The Gameserver has more information. Every service is either designed to allow the Gameserver to store a specific token for each flag or generates one and returns it to the Gameserver. The Gameserver uses this token to check periodically that the flag is still there. Whether or not it gets the stored flag using that token, determines your SLA (Service Level Agreement). You mustn't remove or break any legitimate functionality. Some services can have a vulnerability that directly leaks the flag, which will let you retrieve the flag easily. For others, it will require more effort. Your Vulnbox \u00b6 The Vulnbox is your running instance of the virtual machine image given to you by the organizers. It contains and runs all the services of the competition and should be reachable at all times. The Gameserver stores its flags here and uses the communication with this machine to decide if your services are working as intended or not. This machine is accessible to everyone on the network, and is the target for all the exploits from other teams. Protecting the flags on this machine is what determines your defense points! You normally have one hour from getting access to your Vulnbox until the network between teams is opened and everyone can attack each other. Use this time to get the VM running, then start analyzing what's running on it. It has happened that services with vulnerabilities that are easy to find have been exploited as soon as the actual competition starts. For the Bambi CTF, we will be providing hosted vulnboxes which are accessible via SSH. The other teams \u00b6 All the other registered teams are connected to the same VPN as you. Their Vulnboxes have known IP addresses, all other machines are off-limits! The other teams will run exploits from their own machines, but the VPN infrastructure will use NAT to obfuscate whether a packet came from the Gameserver or another team. Successfully stealing and submitting flags from the Vulnbox of other teams determines your attack score! If you have played jeopardy CTFs before, you already know flag submission. In this game however, you'll have to run you exploits periodically, as new flags get stored by the Gameserver every few minutes. So you probably want to script exploits and submit Flags automatically and you don't spend all your time manually exploiting everyone. Adapted from FAUST CTF Network \u00b6 Summary Game Network: 10.0.0.0/16 Team Vulnbox: 10.0.0.{TeamId}/32 Game Router: 10.0.1.1 Flag Submission: 10.0.13.37:1337 graph LR gamerouter[Game Router] --> flagsubmission[Flag Submission] subgraph team1[Team 1] vuln1[Vulnbox Team 1] --> gamerouter player1[Player 1]--> vpn1[VPN] vpn1 --> vuln1 end subgraph team2[Team 2] vuln2[Vulnbox Team 2] --> gamerouter player2[Player 2]--> vpn2[VPN] vpn2 --> vuln2 end subgraph teamN[Team N] vulnN[Vulnbox Team N] --> gamerouter playerN[Player N]--> vpnN[VPN] vpnN --> vulnN end To access your vulnbox, you must first start it. This will only be possible once the competition has started. Note that you must check in before the competition starts, otherwise you will not be able to start your vulnbox . Please refer to the rules page for more information. After the vulnbox is started, you will be shown your public vulnbox IP address and the root password which you can use to login. You will also be able to download an OpenVPN configuration file only after the vulnbox is started. See the section below for more details. During the first hour of the CTF, the game network will be closed. This means you will not be able to reach the vulnboxes of other teams through the competition network. To check that your vulnbox and OpenVPN client is working as intended, you can try pinging 10.0.1.1 , which is the game router and should also be reachable even while the game network is closed. The router performs SNAT on all game traffic, so all incoming traffic appears to be coming from 10.0.1.1 , regardless of whether it is coming from the game engine or other teams. The 10.0.240.0/24 subnet for the team VPN is identical for all teams. These networks are completely separated from each other and you will not be able to access the devices in the VPN of other teams. You can get a newline-separated list of all (confirmed) vulnbox addresses at the game portal OpenVPN Access for Players \u00b6 We will provide an OpenVPN server through which you can access your vulnbox and the vulnboxes of the other teams (the latter only once the network has been opened). To get seamless access to the game network, install the OpenVPN client for your operating system, and download the client configuration file that will be provided in the enowars portal. The config file will only be available once your have started your vulnbox. Note that the vulnbox serves as OpenVPN server for your team, so you will only be able to access the game network while your own vulnbox is running. The OpenVPN config file can be shared by all members of your team and allows multiple connections at once. Please consult a search engine of your choice or the OpenVPN documentation for help getting started with OpenVPN.","title":"General"},{"location":"play/general.html#playing-a-ctf","text":"","title":"Playing a CTF"},{"location":"play/general.html#general","text":"A typical attack/defense CTF consists of three components.","title":"General"},{"location":"play/general.html#the-gameserver","text":"It is provided by the organizers and runs throughout the competition, starting when the network is opened. It periodically stores flags on your Vulnbox using functionality in the provided services. It then later retrieves these flags, again using existing functionality. The Gameserver does not run exploits! It simply uses the service as intended. Now, why can't the other teams then simply do what the Gameserver does? The Gameserver has more information. Every service is either designed to allow the Gameserver to store a specific token for each flag or generates one and returns it to the Gameserver. The Gameserver uses this token to check periodically that the flag is still there. Whether or not it gets the stored flag using that token, determines your SLA (Service Level Agreement). You mustn't remove or break any legitimate functionality. Some services can have a vulnerability that directly leaks the flag, which will let you retrieve the flag easily. For others, it will require more effort.","title":"The Gameserver"},{"location":"play/general.html#your-vulnbox","text":"The Vulnbox is your running instance of the virtual machine image given to you by the organizers. It contains and runs all the services of the competition and should be reachable at all times. The Gameserver stores its flags here and uses the communication with this machine to decide if your services are working as intended or not. This machine is accessible to everyone on the network, and is the target for all the exploits from other teams. Protecting the flags on this machine is what determines your defense points! You normally have one hour from getting access to your Vulnbox until the network between teams is opened and everyone can attack each other. Use this time to get the VM running, then start analyzing what's running on it. It has happened that services with vulnerabilities that are easy to find have been exploited as soon as the actual competition starts. For the Bambi CTF, we will be providing hosted vulnboxes which are accessible via SSH.","title":"Your Vulnbox"},{"location":"play/general.html#the-other-teams","text":"All the other registered teams are connected to the same VPN as you. Their Vulnboxes have known IP addresses, all other machines are off-limits! The other teams will run exploits from their own machines, but the VPN infrastructure will use NAT to obfuscate whether a packet came from the Gameserver or another team. Successfully stealing and submitting flags from the Vulnbox of other teams determines your attack score! If you have played jeopardy CTFs before, you already know flag submission. In this game however, you'll have to run you exploits periodically, as new flags get stored by the Gameserver every few minutes. So you probably want to script exploits and submit Flags automatically and you don't spend all your time manually exploiting everyone. Adapted from FAUST CTF","title":"The other teams"},{"location":"play/general.html#network","text":"","title":"Network"},{"location":"play/general.html#openvpn-access-for-players","text":"We will provide an OpenVPN server through which you can access your vulnbox and the vulnboxes of the other teams (the latter only once the network has been opened). To get seamless access to the game network, install the OpenVPN client for your operating system, and download the client configuration file that will be provided in the enowars portal. The config file will only be available once your have started your vulnbox. Note that the vulnbox serves as OpenVPN server for your team, so you will only be able to access the game network while your own vulnbox is running. The OpenVPN config file can be shared by all members of your team and allows multiple connections at once. Please consult a search engine of your choice or the OpenVPN documentation for help getting started with OpenVPN.","title":"OpenVPN Access for Players"},{"location":"play/service-status.html","text":"Playing a CTF \u00b6 Service Status \u00b6 OK The service is working as expected. Flags can be stored and retrieved. The functionality of the service is not impaired. MUMBLE The service is online but not working as expected. Some requests to the service were unsucessfull. OFFLINE The service is reported as offline. Flags couldn't be stored or received. RECOVERING The Service was OFFLINE or MUMBLE before. But is now working as expected. Because flags from the previous rounds could not be stored on your service it is marked as RECOVERING. INTERNAL_ERROR The Error is on the event organizers side. Please contact them.","title":"Service Status"},{"location":"play/service-status.html#playing-a-ctf","text":"","title":"Playing a CTF"},{"location":"play/service-status.html#service-status","text":"OK The service is working as expected. Flags can be stored and retrieved. The functionality of the service is not impaired. MUMBLE The service is online but not working as expected. Some requests to the service were unsucessfull. OFFLINE The service is reported as offline. Flags couldn't be stored or received. RECOVERING The Service was OFFLINE or MUMBLE before. But is now working as expected. Because flags from the previous rounds could not be stored on your service it is marked as RECOVERING. INTERNAL_ERROR The Error is on the event organizers side. Please contact them.","title":"Service Status"},{"location":"service/getting-started.html","text":"Create a new Service \u00b6 What's a service pack? \u00b6 A service pack contains: the service the checker documentation workflows to check that everyhing is working as expected Service Structure \u00b6 Examples: https://github.com/enowars/enowars-service-example Service \u00b6 Checker \u00b6 The checker stores and checks the flags in your service. Examples: https://github.com/enowars/enowars-service-example Python Other Other checker lib... Create a Service \u00b6 Describe how to build a new service Create a private \"enowars -service- \" repository in the Enowars Organization . We require a specific project structure Use the provided files, docker-compose, etc. Adhere to the service & checker tenets","title":"Getting started"},{"location":"service/getting-started.html#create-a-new-service","text":"","title":"Create a new Service"},{"location":"service/getting-started.html#whats-a-service-pack","text":"A service pack contains: the service the checker documentation workflows to check that everyhing is working as expected","title":"What's a service pack?"},{"location":"service/getting-started.html#service-structure","text":"Examples: https://github.com/enowars/enowars-service-example","title":"Service Structure"},{"location":"service/getting-started.html#service","text":"","title":"Service"},{"location":"service/getting-started.html#checker","text":"The checker stores and checks the flags in your service. Examples: https://github.com/enowars/enowars-service-example Python Other Other checker lib...","title":"Checker"},{"location":"service/getting-started.html#create-a-service","text":"Describe how to build a new service Create a private \"enowars -service- \" repository in the Enowars Organization . We require a specific project structure Use the provided files, docker-compose, etc. Adhere to the service & checker tenets","title":"Create a Service"},{"location":"service/service.html","text":"Service Development \u00b6 To get to know what the Service is doing visit the Getting Started Page . Your service must be startable via docker-compose up -f docker-compose.yml Apart from that you are free to develop whatevery you like. \ud83d\ude0a","title":"Service Development"},{"location":"service/service.html#service-development","text":"To get to know what the Service is doing visit the Getting Started Page . Your service must be startable via docker-compose up -f docker-compose.yml Apart from that you are free to develop whatevery you like. \ud83d\ude0a","title":"Service Development"},{"location":"service/tenets.html","text":"Service & Checker Tenets \u00b6 In the following we are using RFC2119 Key word to specify the Service and Checker capabilities. Info \ud83d\udd34MUST This word, or the terms \"REQUIRED\" or \"SHALL\", mean that the definition is an absolute requirement of the specification. \ud83d\udd34MUST NOT This phrase, or the phrase \"SHALL NOT\", mean that the definition is an absolute prohibition of the specification. \ud83d\udfe1SHOULD This word, or the adjective \"RECOMMENDED\", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course. \ud83d\udfe1SHOULD NOT This phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood and the case carefully weighed before implementing any behavior described with this label. \ud83d\udfe2MAY This word, or the adjective \"OPTIONAL\", mean that an item is truly optional. One vendor may choose to include the item because a particular marketplace requires it or because the vendor feels that it enhances the product while another vendor may omit the same item. An implementation which does not include a particular option MUST be prepared to interoperate with another implementation which does include the option, though perhaps with reduced functionality. In the same vein an implementation which does include a particular option MUST be prepared to interoperate with another implementation which does not include the option (except, of course, for the feature the option provides.) Service \u00b6 A service: \ud83d\udd34 MUST be able to store and load flags for a specified number of rounds \ud83d\udd34 MUST NOT lose flags if it is restarted \ud83d\udd34 MUST be rebuilt as fast as possible, no redundant build stages should be executed every time the service is built \ud83d\udd34 MUST be able to endure the expected load \ud83d\udfe1 SHOULD NOT be a simple wrapper for a key-value database, and SHOULD expose more complex functionality \ud83d\udfe1 SHOULD NOT rewritable within within the timeframe of the contest \ud83d\udfe2 MAY be written in unexpected languages or using fun frameworks Vulnerabilities \u00b6 A service: \ud83d\udd34 MUST have at least one complex vulnerability \ud83d\udd34 MUST have at least one \"location\" where flags are stored (called flag store) \ud83d\udfe1 SHOULD have more than one vulnerability \ud83d\udfe1 SHOULD NOT have unintended vulnerabilities \ud83d\udfe1 SHOULD NOT have vulnerabilities that allow the deletion but not the retrieval of flags \ud83d\udfe1 SHOULD NOT have vulnerabilities that allow only one attacker to extract a flag \ud83d\udfe2 MAY have additional flag stores, which requires a separate exploit to extract flags A vulnerability: \ud83d\udd34 MUST be exploitable and result in a correct flag \ud83d\udd34 MUST stay exploitable over the course of the complete game (I.e. auto delete old flags, if necessary) \ud83d\udd34 MUST be fixable with reasonable effort and without breaking the checker \ud83d\udd34 MUST be exploitable without renting excessive computing resources \ud83d\udd34 MUST be expoitable with reasonable amounts of network traffic \ud83d\udfe1 SHOULD NOT be easily replayable Checker \u00b6 A checker: \ud83d\udd34 MUST check whether a flag is retrievable, and MUST NOT fail if the flag is retrievable, and MUST fail if the flag is not retrievable \ud83d\udd34 MUST NOT rely on information stored in the service in rounds before the flag was inserted \ud83d\udd34 MUST NOT crash or return unexpected results under any circumstances \ud83d\udd34 MUST log sufficiently detailed information that operators can handle complaints from participants \ud83d\udd34 MUST check the entire functionality of the service and report faulty behavior, even unrelated to the vulnerabilities \ud83d\udfe1 SHOULD not be easily identified by the examination of network traffic \ud83d\udfe1 SHOULD use unusual, incorrect or pseudomalicious input to detect network filters \ud83d\udfe2 MAY use information stored in previous rounds, if it gracefully handles the unexpected absence of that information","title":"Tenets"},{"location":"service/tenets.html#service-checker-tenets","text":"In the following we are using RFC2119 Key word to specify the Service and Checker capabilities. Info \ud83d\udd34MUST This word, or the terms \"REQUIRED\" or \"SHALL\", mean that the definition is an absolute requirement of the specification. \ud83d\udd34MUST NOT This phrase, or the phrase \"SHALL NOT\", mean that the definition is an absolute prohibition of the specification. \ud83d\udfe1SHOULD This word, or the adjective \"RECOMMENDED\", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course. \ud83d\udfe1SHOULD NOT This phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood and the case carefully weighed before implementing any behavior described with this label. \ud83d\udfe2MAY This word, or the adjective \"OPTIONAL\", mean that an item is truly optional. One vendor may choose to include the item because a particular marketplace requires it or because the vendor feels that it enhances the product while another vendor may omit the same item. An implementation which does not include a particular option MUST be prepared to interoperate with another implementation which does include the option, though perhaps with reduced functionality. In the same vein an implementation which does include a particular option MUST be prepared to interoperate with another implementation which does not include the option (except, of course, for the feature the option provides.)","title":"Service &amp; Checker Tenets"},{"location":"service/tenets.html#service","text":"A service: \ud83d\udd34 MUST be able to store and load flags for a specified number of rounds \ud83d\udd34 MUST NOT lose flags if it is restarted \ud83d\udd34 MUST be rebuilt as fast as possible, no redundant build stages should be executed every time the service is built \ud83d\udd34 MUST be able to endure the expected load \ud83d\udfe1 SHOULD NOT be a simple wrapper for a key-value database, and SHOULD expose more complex functionality \ud83d\udfe1 SHOULD NOT rewritable within within the timeframe of the contest \ud83d\udfe2 MAY be written in unexpected languages or using fun frameworks","title":"Service"},{"location":"service/tenets.html#vulnerabilities","text":"A service: \ud83d\udd34 MUST have at least one complex vulnerability \ud83d\udd34 MUST have at least one \"location\" where flags are stored (called flag store) \ud83d\udfe1 SHOULD have more than one vulnerability \ud83d\udfe1 SHOULD NOT have unintended vulnerabilities \ud83d\udfe1 SHOULD NOT have vulnerabilities that allow the deletion but not the retrieval of flags \ud83d\udfe1 SHOULD NOT have vulnerabilities that allow only one attacker to extract a flag \ud83d\udfe2 MAY have additional flag stores, which requires a separate exploit to extract flags A vulnerability: \ud83d\udd34 MUST be exploitable and result in a correct flag \ud83d\udd34 MUST stay exploitable over the course of the complete game (I.e. auto delete old flags, if necessary) \ud83d\udd34 MUST be fixable with reasonable effort and without breaking the checker \ud83d\udd34 MUST be exploitable without renting excessive computing resources \ud83d\udd34 MUST be expoitable with reasonable amounts of network traffic \ud83d\udfe1 SHOULD NOT be easily replayable","title":"Vulnerabilities"},{"location":"service/tenets.html#checker","text":"A checker: \ud83d\udd34 MUST check whether a flag is retrievable, and MUST NOT fail if the flag is retrievable, and MUST fail if the flag is not retrievable \ud83d\udd34 MUST NOT rely on information stored in the service in rounds before the flag was inserted \ud83d\udd34 MUST NOT crash or return unexpected results under any circumstances \ud83d\udd34 MUST log sufficiently detailed information that operators can handle complaints from participants \ud83d\udd34 MUST check the entire functionality of the service and report faulty behavior, even unrelated to the vulnerabilities \ud83d\udfe1 SHOULD not be easily identified by the examination of network traffic \ud83d\udfe1 SHOULD use unusual, incorrect or pseudomalicious input to detect network filters \ud83d\udfe2 MAY use information stored in previous rounds, if it gracefully handles the unexpected absence of that information","title":"Checker"},{"location":"service/checker/checker-dotnet.html","text":"We provide a checker library for an easy start.","title":"Dotnet Checker"},{"location":"service/checker/checker-golang.html","text":"We provide a checker library for an easy start.","title":"Golang Checker"},{"location":"service/checker/checker-python.html","text":"We provide a checker library for an easy start. Development \u00b6 For local development execute cd checker/src gunicorn -c gunicorn.conf.py checker:app You can add those settings to you checker/src/gunicorn.conf.py to make your development faster. reload = True loglevel = 'debug' Writing \u00b6 For a simple checker, subclass BaseChecker ( API Documentation ). from enochecker import BaseChecker , BrokenServiceException , run class AwesomeChecker ( BaseChecker ): flag_count = 2 noise_count = 1 havoc_count = 1 def putflag ( self ): # type: () -> None # TODO: Put flag to service self . debug ( \"flag is {} \" . format ( self . flag )) self . http_post ( \"/putflaghere\" , params = { \"flag\" : self . flag }) # ... def getflag ( self ): # type: () -> None # tTODO: Get the flag. if not self . http_get ( \"/getflag\" ) == self . flag : raise BrokenServiceException ( \"Ooops, wrong Flag\" ) def putnoise ( self ): # put some noise with self . connect () as telnet : telnet . write ( self . noise ) def getnoise ( self ): with self . connect () as telnet : telnet . write ( \"gimmeflag \\n \" ) telnet . read_expect ( self . noise ) def havoc ( self ): self . http ( \"FUNFUN\" ) . text == \"FUNFUN\" if __name__ == \"__main__\" : run ( AwesomeChecker ) To get to know more about what each function should do read the Getting Started Guide . The current flag is made available through the self.flag instance variable. If you wish to place more than one flag per round in different places, the content of self.flag_idx tells you which flag you should deploy, starting with 0 . In that case you should match the value of the variable in the putflag() and getflag() functions and act accordingly. You can communicate the number of flags you want to store per round to the game engine by setting the class variable flag_count . The noise, which is stored/retrieved using the putnoise() and getnoise() functions, is similar to the flag. Your checker should store/retrieve noise to check that the services is still working as intended. Unlike the flag, the noise does not need to remain secret, so you could for example post it on a publicly accessible comment section (provided your service has such functionality) to ensure this still works as intended. You can communicate the number of noises you want to store per round to the game engine by setting the class variable noise_count . The havoc() function is intended to check the functionality of those parts of the service which is not covered by the flag and noise functionality. You can communicate the number of havoc calls you want to receive per round to the game engine by setting the class variable havoc_count . Communicating the service status \u00b6 To tell the game engine about the status of the service under check, you can raise various exceptions during the execution of your functions. If the execution of the function finishes without any exception, it is assumed the status of the service is ok. In case the service appears to be offline, for example because your connection times out, you should raise a OfflineException . In case the service is online but is not working as intended, for example because it responds with unexpected contents or the flag is missing, you should raise a BrokenServiceException . If the function raises any other exceptions, this results in the CHECKER BROKEN status on the scoreboard. This should usually never happen, so make sure to catch all exceptions the functions you use might raise. Persisting data across executions \u00b6 Usually you need to store some information when storing the flag that is needed later. This could be something like usernames and passwords which are necessary to access the flag. There are multiple storage backends (at the moment ~enochecker.storeddict.StoredDict and ~enochecker.nosqldict.NoSqlDict ) that are accessible through a common interface. The self.team_db dictionary is persisted across restarts. A good key for storing your information is usually the flag itself, since you want to access the information you stored during the putflag call during a later getflag call with the same flag in self.flag . An example for using the self.team_db : import secrets [ ... ] class AwesomeChecker ( BaseChecker ): def putflag ( self ): username = secrets . token_hex ( 8 ) password = secrets . token_hex ( 8 ) self . team_db [ self . flag ] = { \"username\" : username , \"password\" : password , } [ ... register with the generated credentials and store the flag ... ] def getflag ( self ): if self . flag not in self . team_db or \"username\" not in self . team_db [ self . flag ] or \"password\" not in self . team_db [ self . flag ]: raise BrokenServiceException ( \"storing the corresponding flag was unsuccessful\" ) username = self . team_db [ self . flag ][ \"username\" ] password = self . team_db [ self . flag ][ \"password\" ] [ ... register with the retrieved credentials and get the flag ... ] Testing \u00b6 Test your checker by executing: Bash pip install enochecker-test ENOCHECKER_TEST_CHECKER_ADDRESS = \"localhost\" ENOCHECKER_TEST_CHECKER_PORT = \"3031\" ENOCHECKER_TEST_SERVICE_ADDRESS = \"localhost\" enochecker_test Powershell pip install enochecker-test $env:ENOCHECKER_TEST_CHECKER_ADDRESS = \"localhost\" $env:ENOCHECKER_TEST_CHECKER_PORT = \"3031\" $env:ENOCHECKER_TEST_SERVICE_ADDRESS = \"localhost\" enochecker_test","title":"Python Checker"},{"location":"service/checker/checker-python.html#development","text":"For local development execute cd checker/src gunicorn -c gunicorn.conf.py checker:app You can add those settings to you checker/src/gunicorn.conf.py to make your development faster. reload = True loglevel = 'debug'","title":"Development"},{"location":"service/checker/checker-python.html#writing","text":"For a simple checker, subclass BaseChecker ( API Documentation ). from enochecker import BaseChecker , BrokenServiceException , run class AwesomeChecker ( BaseChecker ): flag_count = 2 noise_count = 1 havoc_count = 1 def putflag ( self ): # type: () -> None # TODO: Put flag to service self . debug ( \"flag is {} \" . format ( self . flag )) self . http_post ( \"/putflaghere\" , params = { \"flag\" : self . flag }) # ... def getflag ( self ): # type: () -> None # tTODO: Get the flag. if not self . http_get ( \"/getflag\" ) == self . flag : raise BrokenServiceException ( \"Ooops, wrong Flag\" ) def putnoise ( self ): # put some noise with self . connect () as telnet : telnet . write ( self . noise ) def getnoise ( self ): with self . connect () as telnet : telnet . write ( \"gimmeflag \\n \" ) telnet . read_expect ( self . noise ) def havoc ( self ): self . http ( \"FUNFUN\" ) . text == \"FUNFUN\" if __name__ == \"__main__\" : run ( AwesomeChecker ) To get to know more about what each function should do read the Getting Started Guide . The current flag is made available through the self.flag instance variable. If you wish to place more than one flag per round in different places, the content of self.flag_idx tells you which flag you should deploy, starting with 0 . In that case you should match the value of the variable in the putflag() and getflag() functions and act accordingly. You can communicate the number of flags you want to store per round to the game engine by setting the class variable flag_count . The noise, which is stored/retrieved using the putnoise() and getnoise() functions, is similar to the flag. Your checker should store/retrieve noise to check that the services is still working as intended. Unlike the flag, the noise does not need to remain secret, so you could for example post it on a publicly accessible comment section (provided your service has such functionality) to ensure this still works as intended. You can communicate the number of noises you want to store per round to the game engine by setting the class variable noise_count . The havoc() function is intended to check the functionality of those parts of the service which is not covered by the flag and noise functionality. You can communicate the number of havoc calls you want to receive per round to the game engine by setting the class variable havoc_count .","title":"Writing"},{"location":"service/checker/checker-python.html#communicating-the-service-status","text":"To tell the game engine about the status of the service under check, you can raise various exceptions during the execution of your functions. If the execution of the function finishes without any exception, it is assumed the status of the service is ok. In case the service appears to be offline, for example because your connection times out, you should raise a OfflineException . In case the service is online but is not working as intended, for example because it responds with unexpected contents or the flag is missing, you should raise a BrokenServiceException . If the function raises any other exceptions, this results in the CHECKER BROKEN status on the scoreboard. This should usually never happen, so make sure to catch all exceptions the functions you use might raise.","title":"Communicating the service status"},{"location":"service/checker/checker-python.html#persisting-data-across-executions","text":"Usually you need to store some information when storing the flag that is needed later. This could be something like usernames and passwords which are necessary to access the flag. There are multiple storage backends (at the moment ~enochecker.storeddict.StoredDict and ~enochecker.nosqldict.NoSqlDict ) that are accessible through a common interface. The self.team_db dictionary is persisted across restarts. A good key for storing your information is usually the flag itself, since you want to access the information you stored during the putflag call during a later getflag call with the same flag in self.flag . An example for using the self.team_db : import secrets [ ... ] class AwesomeChecker ( BaseChecker ): def putflag ( self ): username = secrets . token_hex ( 8 ) password = secrets . token_hex ( 8 ) self . team_db [ self . flag ] = { \"username\" : username , \"password\" : password , } [ ... register with the generated credentials and store the flag ... ] def getflag ( self ): if self . flag not in self . team_db or \"username\" not in self . team_db [ self . flag ] or \"password\" not in self . team_db [ self . flag ]: raise BrokenServiceException ( \"storing the corresponding flag was unsuccessful\" ) username = self . team_db [ self . flag ][ \"username\" ] password = self . team_db [ self . flag ][ \"password\" ] [ ... register with the retrieved credentials and get the flag ... ]","title":"Persisting data across executions"},{"location":"service/checker/checker-python.html#testing","text":"Test your checker by executing: Bash pip install enochecker-test ENOCHECKER_TEST_CHECKER_ADDRESS = \"localhost\" ENOCHECKER_TEST_CHECKER_PORT = \"3031\" ENOCHECKER_TEST_SERVICE_ADDRESS = \"localhost\" enochecker_test Powershell pip install enochecker-test $env:ENOCHECKER_TEST_CHECKER_ADDRESS = \"localhost\" $env:ENOCHECKER_TEST_CHECKER_PORT = \"3031\" $env:ENOCHECKER_TEST_SERVICE_ADDRESS = \"localhost\" enochecker_test","title":"Testing"},{"location":"service/checker/checker-rust.html","text":"We provide a checker library for an easy start.","title":"Rust Checker"},{"location":"service/checker/checker.html","text":"Checker Development \u00b6 To get to know what the Checker is doing visit the Getting Started Page . Your checker must be startable via docker-compose up -f docker-compose.yml It must conform the specifications. You can write it any language you like, but we provide some guidance for the following: Python You can check whether you Checker is working with the CLI .","title":"General"},{"location":"service/checker/checker.html#checker-development","text":"To get to know what the Checker is doing visit the Getting Started Page . Your checker must be startable via docker-compose up -f docker-compose.yml It must conform the specifications. You can write it any language you like, but we provide some guidance for the following: Python You can check whether you Checker is working with the CLI .","title":"Checker Development"},{"location":"service/checker/testing.html","text":"Testing the Checker \u00b6 We have a testing Library for testing any checker implementation: https://github.com/enowars/enochecker_test You can add it to your repository with this .github/workflows/enochecker_test.yml","title":"Testing"},{"location":"service/checker/testing.html#testing-the-checker","text":"We have a testing Library for testing any checker implementation: https://github.com/enowars/enochecker_test You can add it to your repository with this .github/workflows/enochecker_test.yml","title":"Testing the Checker"}]}